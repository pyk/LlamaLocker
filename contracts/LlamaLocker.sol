// SPDX-License-Identifier: MIT
pragma solidity 0.8.23;

import {IERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import {IERC721} from "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";
import {Ownable, Ownable2Step} from "@openzeppelin/contracts/access/Ownable2Step.sol";

/**
 * @title Llama Locker
 * @author sepyke.eth
 * @dev Lock LLAMA to claim share of the yield generated by the treasury
 */
contract LlamaLocker is ERC721Holder, Ownable2Step {
  struct RewardTokenData {
    uint256 periodFinish;
    uint256 rewardRate;
    uint256 lastUpdateTime;
    uint256 rewardPerTokenStored;
  }

  IERC20[] public rewardTokens;
  IERC721 public nft;
  mapping(IERC20 => RewardTokenData) private rewardTokenData;
  mapping(uint256 tokenId => address owner) private nftOwners;

  error RewardTokenExists();
  error RewardTokenInvalid();
  error LockZeroToken();
  error UnlockOwnerInvalid();

  event RewardTokenAdded(IERC20 rewardToken);

  constructor(address owner_, address nft_) Ownable(owner_) {
    nft = IERC721(nft_);
  }

  function rewardTokensCount() external view returns (uint256 count_) {
    count_ = rewardTokens.length;
  }

  function getRewardTokenData(IERC20 rewardToken_) external view returns (RewardTokenData memory data_) {
    data_ = rewardTokenData[rewardToken_];
  }

  function addRewardToken(IERC20 rewardToken_) external onlyOwner {
    if (address(rewardToken_) == address(0)) revert RewardTokenInvalid();
    if (rewardTokenData[IERC20(rewardToken_)].lastUpdateTime > 0) revert RewardTokenExists();

    rewardTokens.push(IERC20(rewardToken_));
    rewardTokenData[rewardToken_].lastUpdateTime = block.timestamp;
    rewardTokenData[rewardToken_].periodFinish = block.timestamp;

    emit RewardTokenAdded(rewardToken_);
  }

  function lock(uint256[] calldata tokenIds_) external {
    uint256 tokenCount = tokenIds_.length;
    if (tokenCount == 0) revert LockZeroToken();
    for (uint256 i = 0; i < tokenCount; ++i) {
      nft.safeTransferFrom(msg.sender, address(this), tokenIds_[i]);
      nftOwners[tokenIds_[i]] = msg.sender;
    }
  }

  function unlock(uint256[] calldata tokenIds_) external {
    uint256 tokenCount = tokenIds_.length;
    if (tokenCount == 0) revert LockZeroToken();
    for (uint256 i = 0; i < tokenCount; ++i) {
      if (nftOwners[tokenIds_[i]] != msg.sender) revert UnlockOwnerInvalid();
      nft.safeTransferFrom(address(this), msg.sender, tokenIds_[i]);
    }
  }
}
