// SPDX-License-Identifier: MIT
pragma solidity 0.8.23;

import {IERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import {IERC721} from "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";
import {Ownable, Ownable2Step} from "@openzeppelin/contracts/access/Ownable2Step.sol";
import {Math} from "@openzeppelin/contracts/utils/math/Math.sol";

/**
 * @title Llama Locker
 * @author sepyke.eth
 * @dev Lock LLAMA to claim share of the yield generated by the treasury
 */
contract LlamaLocker is ERC721Holder, Ownable2Step {
  using Math for uint256;

  struct RewardTokenData {
    uint256 periodFinish;
    uint256 rewardPerSecond;
    uint256 lastUpdatedAt;
    uint256 rewardPerTokenStored;
  }

  IERC20[] public rewardTokens;
  IERC721 public nft;
  mapping(IERC20 => RewardTokenData) private rewardTokenData;
  mapping(uint256 tokenId => address owner) private nftOwners;
  uint256 public constant REWARD_DURATION = 7 days;

  error RenounceInvalid();
  error RewardTokenExists();
  error RewardTokenInvalid();
  error RewardAmountInvalid();
  error LockZeroToken();
  error UnlockOwnerInvalid();

  event RewardTokenAdded(IERC20 rewardToken);

  constructor(address owner_, address nft_) Ownable(owner_) {
    nft = IERC721(nft_);
  }

  /// @dev This contract ain't gonna work without its owner, ya know?
  function renounceOwnership() public virtual override onlyOwner {
    revert RenounceInvalid();
  }

  function rewardTokensCount() external view returns (uint256 count_) {
    count_ = rewardTokens.length;
  }

  function getRewardTokenData(IERC20 rewardToken_) external view returns (RewardTokenData memory data_) {
    data_ = rewardTokenData[rewardToken_];
  }

  function addRewardToken(IERC20 rewardToken_) external onlyOwner {
    if (address(rewardToken_) == address(0)) revert RewardTokenInvalid();
    if (rewardTokenData[IERC20(rewardToken_)].lastUpdatedAt > 0) revert RewardTokenExists();

    rewardTokens.push(IERC20(rewardToken_));
    rewardTokenData[rewardToken_].lastUpdatedAt = block.timestamp;
    rewardTokenData[rewardToken_].periodFinish = block.timestamp;

    emit RewardTokenAdded(rewardToken_);
  }

  /// @notice Owner can add reward on weekly basis (vlCVX styles)
  function addReward(IERC20 rewardToken_, uint256 amount_) external onlyOwner {
    if (amount_ == 0) revert RewardAmountInvalid();
    if (rewardTokenData[IERC20(rewardToken_)].lastUpdatedAt == 0) revert RewardTokenInvalid();

    RewardTokenData storage data = rewardTokenData[rewardToken_];

    if (block.timestamp >= data.periodFinish) {
      data.rewardPerSecond = amount_ / REWARD_DURATION;
    } else {
      uint256 remainingSeconds = data.periodFinish - block.timestamp;
      uint256 leftoverAmount = remainingSeconds * data.rewardPerSecond;
      data.rewardPerSecond = (amount_ + leftoverAmount) / REWARD_DURATION;
    }

    data.lastUpdatedAt = block.timestamp;
    data.periodFinish = block.timestamp + REWARD_DURATION;
  }

  function lock(uint256[] calldata tokenIds_) external {
    uint256 tokenCount = tokenIds_.length;
    if (tokenCount == 0) revert LockZeroToken();
    for (uint256 i = 0; i < tokenCount; ++i) {
      nft.safeTransferFrom(msg.sender, address(this), tokenIds_[i]);
      nftOwners[tokenIds_[i]] = msg.sender;
    }
  }

  function unlock(uint256[] calldata tokenIds_) external {
    uint256 tokenCount = tokenIds_.length;
    if (tokenCount == 0) revert LockZeroToken();
    for (uint256 i = 0; i < tokenCount; ++i) {
      if (nftOwners[tokenIds_[i]] != msg.sender) revert UnlockOwnerInvalid();
      nft.safeTransferFrom(address(this), msg.sender, tokenIds_[i]);
    }
  }
}
