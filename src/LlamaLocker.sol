// SPDX-License-Identifier: MIT
pragma solidity 0.8.23;

import {Ownable, Ownable2Step} from "@openzeppelin/contracts/access/Ownable2Step.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import {IERC721} from "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";
import {Math} from "@openzeppelin/contracts/utils/math/Math.sol";
import {SafeCast} from "@openzeppelin/contracts/utils/math/SafeCast.sol";

/**
 * @title Llama Locker
 * @author sepyke.eth
 * @dev Lock LLAMA to claim share of the yield generated by the treasury
 */
contract LlamaLocker is ERC721Holder, Ownable2Step {
    using SafeERC20 for IERC20;
    using SafeCast for uint256;
    using Math for uint256;

    IERC721 public nft;
    address[] public rewardTokens;
    uint256 public constant EPOCH_DURATION = 7 days;
    uint256 public constant LOCK_DURATION_IN_EPOCH = 4; // 4 epochs

    struct NFTLock {
        address owner;
        uint256 lockedAt;
    }

    struct Claimable {
        address token;
        uint256 amount;
    }

    struct Shares {
        uint256 prevShares;
        uint256 epoch;
        uint256 nextShares;
    }

    struct RewardIndex {
        int256 prevIndex;
        uint256 epoch;
        int256 nextIndex;
    }

    struct RewardPerShare {
        uint256 value;
        uint256 updatedAt;
    }

    mapping(uint256 tokenId => NFTLock lock) public locks;
    mapping(address account => Shares shares) private accountShares;
    mapping(address account => mapping(address token => RewardIndex index)) private rewardIndices;
    mapping(address token => RewardPerShare rps) private rewardPerShares;
    mapping(address account => mapping(address token => uint256 amount)) private claimedRewards;

    Shares private totalShares;

    // TODO(pyk): check variables below

    error RenounceInvalid();

    error InvalidTokenCount();
    error InvalidLockOwner();
    error InvalidUnlockWindow();
    error InvalidRewardToken();
    error InvalidRewardAmount();
    error InvalidAccountShareDecrease();
    error InvalidTotalShares();

    event NewRewardTokens(address[] token);
    event RewardDistributed(IERC20 token, uint256 amount);
    event NewLocks(address owner, uint256[] tokenIds);
    event NewUnlocks(address owner, uint256[] tokenIds);

    constructor(address owner_, address nft_) Ownable(owner_) {
        nft = IERC721(nft_);
    }

    /// @dev This contract ain't gonna work without its owner, ya know?
    function renounceOwnership() public virtual override onlyOwner {
        revert RenounceInvalid();
    }

    function _getCurrentEpochStart() private view returns (uint256) {
        uint256 start = ((block.timestamp / EPOCH_DURATION) * EPOCH_DURATION);
        return start;
    }

    function _getNextEpochStart() private view returns (uint256) {
        return _getCurrentEpochStart() + EPOCH_DURATION;
    }

    function getShares(address account_) public view returns (uint256 shares) {
        Shares memory accountShare = accountShares[account_];
        if (block.timestamp < accountShare.epoch) {
            shares = accountShare.prevShares;
        } else {
            shares = accountShare.nextShares;
        }
    }

    function getTotalShares() public view returns (uint256 shares) {
        if (block.timestamp < totalShares.epoch) {
            shares = totalShares.prevShares;
        } else {
            shares = totalShares.nextShares;
        }
    }

    function _getRewardIndex(address account_, address token_) private view returns (int256 index) {
        RewardIndex memory rewardIndex = rewardIndices[account_][token_];
        Shares memory accountShare = accountShares[account_];
        RewardPerShare memory rps = rewardPerShares[token_];

        // If the user have pending shares when admin distribute the reward token
        // then it's mean that the user lock the NFT before rewardPerShare is updated;
        // hence we need to calculate the reward index manually to adjust claimable amount
        // of the user
        if (accountShare.epoch > rps.updatedAt) {
            index = -rps.value.mulDiv(accountShare.nextShares, 1 ether, Math.Rounding.Floor).toInt256();
        } else {
            if (block.timestamp < rewardIndex.epoch) {
                index = rewardIndex.prevIndex;
            } else {
                index = rewardIndex.nextIndex;
            }
        }
    }

    function _increaseShares(address account_, uint256 tokenCount_) private {
        uint256 currentEpochStart = _getCurrentEpochStart();
        uint256 nextEpochStart = currentEpochStart + EPOCH_DURATION;
        uint256 amount = tokenCount_ * 1 ether;

        Shares storage accountShare = accountShares[account_];

        if (accountShare.epoch <= currentEpochStart) {
            accountShare.prevShares = accountShare.nextShares;
        }
        accountShare.epoch = nextEpochStart;
        accountShare.nextShares += amount;

        if (totalShares.epoch <= currentEpochStart) {
            totalShares.prevShares = totalShares.nextShares;
        }
        totalShares.epoch = nextEpochStart;
        totalShares.nextShares += amount;

        uint256 rewardTokenCount = rewardTokens.length;
        for (uint256 i = 0; i < rewardTokenCount; ++i) {
            address rewardToken = rewardTokens[i];
            uint256 rewardPerShare = rewardPerShares[rewardToken].value;
            RewardIndex storage index = rewardIndices[account_][rewardToken];

            if (index.epoch <= currentEpochStart) {
                index.prevIndex = index.nextIndex;
            }
            index.epoch = nextEpochStart;
            index.nextIndex -= rewardPerShare.mulDiv(amount, 1 ether).toInt256();
        }
    }

    function _lockNFT(address owner_, uint256 tokenId_) private {
        nft.safeTransferFrom(owner_, address(this), tokenId_);
        locks[tokenId_] = NFTLock({owner: owner_, lockedAt: block.timestamp});
    }

    function lock(uint256[] calldata tokenIds_) external {
        uint256 tokenIdCount = tokenIds_.length;
        if (tokenIdCount == 0) revert InvalidTokenCount();

        _increaseShares(msg.sender, tokenIdCount);

        for (uint8 i = 0; i < tokenIdCount; ++i) {
            _lockNFT(msg.sender, tokenIds_[i]);
        }

        emit NewLocks(msg.sender, tokenIds_);
    }

    function _decreaseShares(address account_, uint256 tokenCount_) private {
        uint256 currentEpochStart = _getCurrentEpochStart();
        uint256 amount = tokenCount_ * 1 ether;
        uint256 shares = getShares(account_);
        if (shares < amount) revert InvalidAccountShareDecrease();

        Shares storage accountShare = accountShares[account_];
        if (accountShare.epoch == 0) revert InvalidAccountShareDecrease();

        uint256 newShares = shares - amount;
        accountShare.epoch = currentEpochStart;
        accountShare.prevShares = newShares;
        accountShare.nextShares = newShares;

        uint256 currentTotalShares = getTotalShares();

        if (currentTotalShares < amount) revert InvalidAccountShareDecrease();
        uint256 newTotalShares = currentTotalShares - amount;
        totalShares.prevShares = newTotalShares;
        totalShares.epoch = currentEpochStart;
        totalShares.nextShares = newTotalShares;
    }

    function _unlockNFT(address owner_, uint256 tokenId_) internal {
        NFTLock memory locked = locks[tokenId_];
        if (owner_ != locked.owner) revert InvalidLockOwner();

        uint256 lockedDuration = block.timestamp - locked.lockedAt;
        uint256 lockedDurationInEpoch = lockedDuration / EPOCH_DURATION;
        if (lockedDurationInEpoch == 0) revert InvalidUnlockWindow();

        uint256 modulo = lockedDurationInEpoch % LOCK_DURATION_IN_EPOCH;
        if (modulo != 0) revert InvalidUnlockWindow();

        nft.safeTransferFrom(address(this), owner_, tokenId_);
    }

    function unlock(uint256[] calldata tokenIds_) external {
        uint256 tokenIdCount = tokenIds_.length;
        if (tokenIdCount == 0) revert InvalidTokenCount();

        for (uint256 i = 0; i < tokenIdCount; ++i) {
            _unlockNFT(msg.sender, tokenIds_[i]);
        }

        // TODO(pyk): claim rewards here

        _decreaseShares(msg.sender, tokenIdCount);

        emit NewUnlocks(msg.sender, tokenIds_);
    }

    function _addRewardToken(address token_) private {
        if (address(token_) == address(0)) revert InvalidRewardToken();
        if (rewardPerShares[token_].updatedAt > 0) revert InvalidRewardToken();

        rewardTokens.push(token_);

        RewardPerShare storage rps = rewardPerShares[token_];
        rps.value = 0;
        rps.updatedAt = block.timestamp;
    }

    function addRewardTokens(address[] memory tokens_) external onlyOwner {
        uint256 tokenCount = tokens_.length;
        if (tokenCount == 0) revert InvalidTokenCount();
        for (uint256 i = 0; i < tokens_.length; i++) {
            _addRewardToken(tokens_[i]);
        }

        emit NewRewardTokens(tokens_);
    }

    function getRewardTokenCount() external view returns (uint256 count) {
        count = rewardTokens.length;
    }

    function distributeRewardToken(address token_, uint256 amount_) external onlyOwner {
        if (rewardPerShares[token_].updatedAt == 0) revert InvalidRewardToken();
        if (amount_ == 0) revert InvalidRewardAmount();

        uint256 totalSharesAtCurrentEpoch = getTotalShares();
        if (totalSharesAtCurrentEpoch == 0) revert InvalidTotalShares();

        RewardPerShare storage rps = rewardPerShares[token_];
        rps.value += amount_.mulDiv(1 ether, totalSharesAtCurrentEpoch, Math.Rounding.Floor);
        rps.updatedAt = block.timestamp;
    }

    function claimable(address account_, address token_) public view returns (uint256 amount) {
        if (rewardPerShares[token_].updatedAt == 0) revert InvalidRewardToken();

        uint256 shares = getShares(account_);
        if (shares == 0) return 0;

        int256 rewardIndex = _getRewardIndex(account_, token_);
        uint256 claimedAmount = claimedRewards[account_][token_];
        uint256 rewardPerShare = rewardPerShares[token_].value;
        int256 totalRewardAmount = rewardPerShare.mulDiv(shares, 1 ether, Math.Rounding.Floor).toInt256() + rewardIndex;
        amount = uint256(totalRewardAmount) - claimedAmount;
    }

    function claimables(address account_) public view returns (Claimable[] memory results) {
        uint256 rewardTokenCount = rewardTokens.length;
        results = new Claimable[](rewardTokenCount);
        for (uint256 i = 0; i < rewardTokenCount; i++) {
            address token = rewardTokens[i];
            uint256 amount = claimable(account_, token);
            results[i] = Claimable({token: token, amount: amount});
        }
    }
}
