// SPDX-License-Identifier: MIT
pragma solidity 0.8.23;

import {Ownable, Ownable2Step} from "@openzeppelin/contracts/access/Ownable2Step.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import {IERC721} from "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";
import {Math} from "@openzeppelin/contracts/utils/math/Math.sol";
import {SafeCast} from "@openzeppelin/contracts/utils/math/SafeCast.sol";

/**
 * @title Llama Locker
 * @author sepyke.eth
 * @dev Lock LLAMA to claim share of the yield generated by the treasury
 * @custom:credits LlamaLocker is inspired by CvxLockerV2
 */
contract LlamaLocker is ERC721Holder, Ownable2Step {
    using SafeERC20 for IERC20;
    using SafeCast for uint256;
    using Math for uint256;

    IERC721 public nft;
    IERC20[] public tokens; // yield token
    uint256 public constant EPOCH_DURATION = 7 days;
    uint256 public constant LOCK_DURATION_IN_EPOCH = 4; // 4 epochs
    uint256 public totalLockedNFT;

    struct Epoch {
        uint48 startAt;
    }

    struct LockInput {
        address recipient;
        uint256 nftId;
    }

    struct LockInfo {
        address owner;
        uint256 lockedAtEpochIndex;
        address recipient;
    }

    struct Claimable {
        IERC20 token;
        uint256 amount;
    }

    struct YieldInfo {
        uint208 amountPerSecond;
        uint48 epochEndAt;
        uint208 amountPerNFTStored;
        uint48 updatedAt;
    }

    struct NFTYield {
        uint256 amount;
        uint256 paidAmount;
    }

    Epoch[] public epochs;
    mapping(uint256 nftId => LockInfo info) public locks;
    mapping(IERC20 token => YieldInfo info) private yields;
    mapping(uint256 nftId => mapping(IERC20 token => NFTYield)) private nftYields;

    // TODO(pyk): check variables below

    error RenounceInvalid();
    error TokenExists();
    error TokenNotExists();
    error RewardAmountInvalid();
    error Empty();

    error InvalidLockCount();
    error InvalidUnlockCount();
    error InvalidYieldRecipient();
    error InvalidLockOwner();
    error InvalidUnlockWindow();

    event TokenAdded(IERC20 token);
    event RewardDistributed(IERC20 token, uint256 amount);
    event Locked(address owner, uint256 nftId);
    event Unlocked(address recipient, uint256 nftId);

    constructor(address owner_, address nft_) Ownable(owner_) {
        nft = IERC721(nft_);

        uint48 startAt = _getCurrentEpochStart();
        epochs.push(Epoch({startAt: startAt}));
    }

    /// @dev This contract ain't gonna work without its owner, ya know?
    function renounceOwnership() public virtual override onlyOwner {
        revert RenounceInvalid();
    }

    function _getCurrentEpochStart() private view returns (uint48) {
        uint256 start = ((block.timestamp / EPOCH_DURATION) * EPOCH_DURATION);
        return start.toUint48();
    }

    function _getNextEpochStart() internal view returns (uint48) {
        return (_getCurrentEpochStart() + EPOCH_DURATION).toUint48();
    }

    /// @dev Backfill epochs up to current epoch
    /// @dev Current epoch index is epochs.length - 1
    function _backfillEpochs() internal {
        uint48 currentEpochStart = _getCurrentEpochStart();
        uint256 epochindex = epochs.length;

        if (epochs[epochindex - 1].startAt < currentEpochStart) {
            while (epochs[epochs.length - 1].startAt != currentEpochStart) {
                uint48 nextStartAt = (epochs[epochs.length - 1].startAt + EPOCH_DURATION).toUint48();
                epochs.push(Epoch({startAt: nextStartAt}));
            }
        }
    }

    function _lock(LockInput memory input_, address owner_, uint256 currentEpochIndex_) internal {
        if (input_.recipient == address(0)) revert InvalidYieldRecipient();
        nft.safeTransferFrom(owner_, address(this), input_.nftId);
        locks[input_.nftId] =
            LockInfo({owner: owner_, recipient: input_.recipient, lockedAtEpochIndex: currentEpochIndex_});
        emit Locked(owner_, input_.nftId);
    }

    /// @dev Locked NFT cannot be withdrawn for LOCK_DURATION_IN_EPOCH and are eligible to receive share of yields
    function lock(LockInput[] calldata _inputs) external {
        uint256 lockedCount = _inputs.length;
        if (lockedCount == 0) revert InvalidLockCount();

        _backfillEpochs();
        uint256 currentEpochIndex = epochs.length - 1;
        totalLockedNFT += lockedCount;

        for (uint8 i = 0; i < lockedCount; ++i) {
            _lock(_inputs[i], msg.sender, currentEpochIndex);
        }
    }

    function _unlock(address unlocker_, uint256 tokenId_, uint256 currendEpochIndex_) internal {
        LockInfo memory lockInfo = locks[tokenId_];
        if (unlocker_ != lockInfo.owner) revert InvalidLockOwner();
        // TODO(pyk): mark lockInfo as unlocked here

        uint256 lockedDurationInEpoch = currendEpochIndex_ - lockInfo.lockedAtEpochIndex;
        if (lockedDurationInEpoch == 0) revert InvalidUnlockWindow();

        uint256 modulo = lockedDurationInEpoch % (LOCK_DURATION_IN_EPOCH + 1);
        if (modulo != 0) revert InvalidUnlockWindow();

        nft.safeTransferFrom(address(this), unlocker_, tokenId_);
        emit Unlocked(unlocker_, tokenId_);
    }

    /// @dev Unlock NFT; it will revert if nftId have invalid unlock window
    function unlock(uint256[] calldata _nftIds) external {
        uint256 unlockCount = _nftIds.length;
        if (unlockCount == 0) revert InvalidUnlockCount();

        _backfillEpochs();
        uint256 currentEpochIndex = epochs.length - 1;
        totalLockedNFT -= unlockCount;

        for (uint256 i = 0; i < unlockCount; ++i) {
            _unlock(msg.sender, _nftIds[i], currentEpochIndex);
        }
    }

    //************************************************************//
    //                           Yield                            //
    //************************************************************//

    function addTokens(IERC20[] memory _tokens) external onlyOwner {
        uint256 tokenCount = _tokens.length;
        if (tokenCount == 0) revert Empty();

        for (uint256 i = 0; i < _tokens.length; i++) {
            IERC20 token = tokens[i];

            if (yields[token].updatedAt > 0) revert TokenExists();
            tokens.push(token);
            yields[token].updatedAt = block.timestamp.toUint48();
            yields[token].epochEndAt = block.timestamp.toUint48();

            emit TokenAdded(token);
        }
    }

    function getTokenCount() external view returns (uint256 count) {
        count = tokens.length;
    }

    function getYieldInfo(IERC20 _token) external view returns (YieldInfo memory info) {
        info = yields[_token];
    }

    /// @dev Calculate yield amount per NFT
    function _yieldAmountPerNFT(IERC20 _token) internal view returns (uint256) {
        if (totalLockedNFT == 0) return yields[_token].amountPerNFTStored;

        YieldInfo memory yieldInfo = yields[_token];
        uint256 prevYieldAmountPerNFT = uint256(yieldInfo.amountPerNFTStored);
        uint256 epochEndAt = Math.min(uint256(yieldInfo.epochEndAt), block.timestamp);
        uint256 timeDelta = epochEndAt - uint256(yieldInfo.updatedAt);
        uint256 yieldAmountPerNFT = (timeDelta * yieldInfo.amountPerSecond) / totalLockedNFT;
        return prevYieldAmountPerNFT + yieldAmountPerNFT;
    }

    function _getClaimableYield(uint256 _nftId, IERC20 _token) internal view returns (uint256) {
        NFTYield memory nftYield = nftYields[_nftId][_token];
        uint256 amountPerNFT = _yieldAmountPerNFT(_token);
        return (amountPerNFT - nftYield.paidAmount) + nftYield.amount;
    }

    /// @dev Get claimable yield of nftId
    function getClaimableYield(uint256 _nftId) external view returns (Claimable[] memory claimables) {
        claimables = new Claimable[](tokens.length);
        for (uint256 i = 0; i < tokens.length; i++) {
            IERC20 token = tokens[i];
            claimables[i].token = token;
            claimables[i].amount = _getClaimableYield(_nftId, token);
        }
    }

    // TODO(pyk): review functions below

    /// @dev Update reward states
    // function _updateRewardStates() internal {
    //     for (uint256 i = 0; i < tokens.length; i++) {
    //         IERC20 token = tokens[i];
    //         rewardStates[token].rewardPerNFTStored = _rewardPerNFT(token).toUint208();
    //         rewardStates[token].updatedAt = Math.min(rewardStates[token].epochEndAt, block.timestamp).toUint48();
    //     }
    // }

    // / @notice Distribute rewards to lockers
    // / @param _token The reward token address
    // / @param _amount The amount of reward token
    // function distribute(IERC20 _token, uint256 _amount) external onlyOwner {
    //     if (rewardStates[_token].updatedAt == 0) revert RewardTokenNotExists();
    //     if (_amount == 0) revert RewardAmountInvalid();
    //     if (totalLockedNFT == 0) revert NoLockers();

    //     _updateRewardStates();

    //     RewardState storage rewardState = rewardStates[_token];
    //     if (block.timestamp >= rewardState.epochEndAt) {
    //         rewardState.rewardPerSecond = (_amount / EPOCH_DURATION).toUint208();
    //     } else {
    //         uint256 remaining = rewardState.epochEndAt - block.timestamp;
    //         uint256 leftover = remaining * rewardState.rewardPerSecond;
    //         rewardState.rewardPerSecond = ((_amount + leftover) / EPOCH_DURATION).toUint208();
    //     }

    //     rewardState.updatedAt = block.timestamp.toUint48();
    //     rewardState.epochEndAt = (block.timestamp + EPOCH_DURATION).toUint48();

    //     _token.safeTransferFrom(msg.sender, address(this), _amount);
    //     emit RewardDistributed(_token, _amount);
    // }

    // function _earned(address _account, IERC20 _token, uint256 _lockedAmount) internal view returns (uint256) {
    //     uint256 rewardPerNFTDiff = _rewardPerNFT(_token) - accountRewardPerNFTPaid[_account][_token];
    //     return (_lockedAmount * rewardPerNFTDiff) + rewards[_account][_token];
    // }

    // function _updateAccountReward(address _account) internal {
    //     LockOverview memory overview = accountLockOverviews[_account];
    //     for (uint256 i = 0; i < tokens.length; i++) {
    //         IERC20 token = tokens[i];
    //         RewardState memory rewardState = rewardStates[token];
    //         rewards[_account][token] = _earned(_account, token, overview.lockedAmount);
    //         accountRewardPerNFTPaid[_account][token] = rewardState.rewardPerNFTStored;
    //     }
    // }
}
