// SPDX-License-Identifier: MIT
pragma solidity 0.8.23;

import {Ownable, Ownable2Step} from "@openzeppelin/contracts/access/Ownable2Step.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import {IERC721} from "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";
import {ReentrancyGuard} from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import {Math} from "@openzeppelin/contracts/utils/math/Math.sol";
import {SafeCast} from "@openzeppelin/contracts/utils/math/SafeCast.sol";

/**
 * @title Llama Locker
 * @author sepyke.eth
 * @dev Lock LLAMA to claim share of the yield generated by the treasury
 */
contract LlamaLocker is ERC721Holder, Ownable2Step, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeCast for uint256;
    using Math for uint256;

    IERC721 public nft;
    uint256 public constant EPOCH_DURATION = 7 days;
    uint256 public constant LOCK_DURATION_IN_EPOCH = 4; // 4 epochs

    struct NFTLock {
        address owner;
        uint256 lockedAt;
    }

    struct Claimable {
        address token;
        uint256 amount;
    }

    mapping(uint256 tokenId => NFTLock lock) public locks;
    mapping(address account => uint256 shares) private accountShares;
    mapping(address account => mapping(address token => int256 index)) private rewardIndices;
    mapping(address account => mapping(address token => uint256 amount)) private claimedRewards;

    address[] public rewardTokens;
    mapping(address token => bool valid) private isValidRewardToken;
    mapping(address token => uint256 rps) private rewardPerShares;
    uint256 private totalShares;

    error InvalidAction();
    error InvalidTokenCount();
    error InvalidLockOwner();
    error InvalidUnlockWindow();
    error InvalidRewardToken();
    error InvalidRewardAmount();
    error InvalidTotalShares();
    error InvalidRecipient();

    event NewRewardTokens(address[] token);
    event RewardDistributed(IERC20 token, uint256 amount);
    event NewLocks(address owner, uint256[] tokenIds);
    event NewUnlocks(address owner, uint256[] tokenIds);

    constructor(address owner_, address nft_) Ownable(owner_) {
        nft = IERC721(nft_);
    }

    /// @dev This contract ain't gonna work without its owner, ya know?
    function renounceOwnership() public virtual override onlyOwner {
        revert InvalidAction();
    }

    function _increaseShares(address account_, uint256 tokenCount_) private {
        uint256 amount = tokenCount_ * 1 ether;

        accountShares[account_] += amount;
        totalShares += amount;

        uint256 rewardTokenCount = rewardTokens.length;
        for (uint256 i = 0; i < rewardTokenCount; ++i) {
            address rewardToken = rewardTokens[i];
            uint256 rewardPerShare = rewardPerShares[rewardToken];
            rewardIndices[account_][rewardToken] -= rewardPerShare.mulDiv(amount, 1 ether).toInt256();
        }
    }

    function _lockNFT(address owner_, uint256 tokenId_) private {
        nft.safeTransferFrom(owner_, address(this), tokenId_);
        locks[tokenId_] = NFTLock({owner: owner_, lockedAt: block.timestamp});
    }

    function lock(uint256[] calldata tokenIds_) external {
        uint256 tokenIdCount = tokenIds_.length;
        if (tokenIdCount == 0) revert InvalidTokenCount();

        _increaseShares(msg.sender, tokenIdCount);

        for (uint8 i = 0; i < tokenIdCount; ++i) {
            _lockNFT(msg.sender, tokenIds_[i]);
        }

        emit NewLocks(msg.sender, tokenIds_);
    }

    function _decreaseShares(address account_, uint256 tokenCount_) private {
        uint256 amount = tokenCount_ * 1 ether;

        accountShares[account_] -= amount;
        totalShares -= amount;

        uint256 rewardTokenCount = rewardTokens.length;
        for (uint256 i = 0; i < rewardTokenCount; ++i) {
            address rewardToken = rewardTokens[i];
            uint256 rewardPerShare = rewardPerShares[rewardToken];
            rewardIndices[account_][rewardToken] += rewardPerShare.mulDiv(amount, 1 ether).toInt256();
        }
    }

    function _unlockNFT(address owner_, uint256 tokenId_) internal {
        NFTLock storage locked = locks[tokenId_];
        if (owner_ != locked.owner) revert InvalidLockOwner();

        uint256 lockedDuration = block.timestamp - locked.lockedAt;
        uint256 lockedDurationInEpoch = lockedDuration / EPOCH_DURATION;
        if (lockedDurationInEpoch == 0) revert InvalidUnlockWindow();

        uint256 modulo = lockedDurationInEpoch % LOCK_DURATION_IN_EPOCH;
        if (modulo != 0) revert InvalidUnlockWindow();

        locks[tokenId_] = NFTLock({owner: address(0), lockedAt: 0});
        nft.safeTransferFrom(address(this), owner_, tokenId_);
    }

    function unlock(uint256[] calldata tokenIds_) external {
        uint256 tokenIdCount = tokenIds_.length;
        if (tokenIdCount == 0) revert InvalidTokenCount();

        for (uint256 i = 0; i < tokenIdCount; ++i) {
            _unlockNFT(msg.sender, tokenIds_[i]);
        }

        claim(msg.sender);
        _decreaseShares(msg.sender, tokenIdCount);
        emit NewUnlocks(msg.sender, tokenIds_);
    }

    function _addRewardToken(address token_) private {
        if (address(token_) == address(0)) revert InvalidRewardToken();
        if (isValidRewardToken[token_] == true) revert InvalidRewardToken(); // can't add twice

        rewardTokens.push(token_);
        isValidRewardToken[token_] = true;
    }

    function addRewardTokens(address[] memory tokens_) external onlyOwner {
        uint256 tokenCount = tokens_.length;
        if (tokenCount == 0) revert InvalidTokenCount();

        for (uint256 i = 0; i < tokens_.length; i++) {
            _addRewardToken(tokens_[i]);
        }

        emit NewRewardTokens(tokens_);
    }

    function getRewardTokenCount() external view returns (uint256 count) {
        count = rewardTokens.length;
    }

    function distributeRewardToken(address token_, uint256 amount_) external onlyOwner {
        if (!isValidRewardToken[token_]) revert InvalidRewardToken();
        if (amount_ == 0) revert InvalidRewardAmount();
        if (totalShares == 0) revert InvalidTotalShares();
        rewardPerShares[token_] += amount_.mulDiv(1 ether, totalShares, Math.Rounding.Floor);
        IERC20(token_).safeTransferFrom(msg.sender, address(this), amount_);
    }

    function claimable(address account_, address token_) public view returns (uint256 amount) {
        if (!isValidRewardToken[token_]) revert InvalidRewardToken();
        uint256 shares = accountShares[account_];
        if (shares == 0) return 0;
        int256 rewardIndex = rewardIndices[account_][token_];
        uint256 claimedAmount = claimedRewards[account_][token_];
        uint256 rewardPerShare = rewardPerShares[token_];
        int256 totalRewardAmount = rewardPerShare.mulDiv(shares, 1 ether, Math.Rounding.Floor).toInt256() + rewardIndex;
        amount = uint256(totalRewardAmount) - claimedAmount;
    }

    function claimables(address account_) public view returns (Claimable[] memory results) {
        uint256 rewardTokenCount = rewardTokens.length;
        results = new Claimable[](rewardTokenCount);
        for (uint256 i = 0; i < rewardTokenCount; ++i) {
            address token = rewardTokens[i];
            uint256 amount = claimable(account_, token);
            results[i] = Claimable({token: token, amount: amount});
        }
    }

    function claim(address recipient_) public nonReentrant returns (Claimable[] memory results) {
        if (recipient_ == address(0)) revert InvalidRecipient();

        results = claimables(msg.sender);
        uint256 resultsCount = results.length;
        for (uint256 i = 0; i < resultsCount; ++i) {
            Claimable memory result = results[i];
            if (result.amount > 0) {
                claimedRewards[msg.sender][result.token] += result.amount;
                IERC20(result.token).safeTransfer(recipient_, result.amount);
            }
        }
    }

    function getClaimedRewards(address account_) external view returns (Claimable[] memory results) {
        uint256 rewardTokenCount = rewardTokens.length;
        results = new Claimable[](rewardTokenCount);
        for (uint256 i = 0; i < rewardTokenCount; ++i) {
            address token = rewardTokens[i];
            uint256 amount = claimedRewards[account_][token];
            results[i] = Claimable({token: token, amount: amount});
        }
    }
}
